import{P as e,h as t,i as n,e as a,j as r,I as s,k as i,B as o,l,m as c,H as f,W as u,A as h,n as w,o as p,C as y,a as d,E as b,p as S,q as A,r as g,F as m,s as z,t as C,u as k}from"./index-C2Dn2Uko.js";function O(e){return new DataView(e.array.buffer,e.offset.value,e.size)}function x(e){const t=e.viewer.buffer.slice(e.offset.value,e.offset.value+e.size),n=new Uint8Array(function(e){let t=e.byteLength;const n=new Array;let a=0;const r=new DataView(e);for(;t>0;){const e=r.getInt8(a++);if(e<0){const s=-e;t-=s+1;for(let e=0;e<s;e++)n.push(r.getUint8(a++))}else{const s=e;t-=2;const i=r.getUint8(a++);for(let e=0;e<s+1;e++)n.push(i)}}return n}(t)),a=new Uint8Array(n.length);return r(n),s(n,a),new DataView(a.buffer)}function E(e){const t=e.array.slice(e.offset.value,e.offset.value+e.size),n=fflate.unzlibSync(t),a=new Uint8Array(n.length);return r(n),s(n,a),new DataView(a.buffer)}function U(e){const t=e.array.slice(e.offset.value,e.offset.value+e.size),n=fflate.unzlibSync(t),a=e.lines*e.channels*e.width,r=1==e.type?new Uint16Array(a):new Uint32Array(a);let s=0,i=0;const o=new Array(4);for(let l=0;l<e.lines;l++)for(let t=0;t<e.channels;t++){let t=0;switch(e.type){case 1:o[0]=s,o[1]=o[0]+e.width,s=o[1]+e.width;for(let a=0;a<e.width;++a){t+=n[o[0]++]<<8|n[o[1]++],r[i]=t,i++}break;case 2:o[0]=s,o[1]=o[0]+e.width,o[2]=o[1]+e.width,s=o[2]+e.width;for(let a=0;a<e.width;++a){t+=n[o[0]++]<<24|n[o[1]++]<<16|n[o[2]++]<<8,r[i]=t,i++}}}return new DataView(r.buffer)}function v(e){const n=e.viewer,a={value:e.offset.value},r=new Uint16Array(e.width*e.scanlineBlockSize*(e.channels*e.type)),s=new Uint8Array(o);let y=0;const d=new Array(e.channels);for(let t=0;t<e.channels;t++)d[t]={},d[t].start=y,d[t].end=d[t].start,d[t].nx=e.width,d[t].ny=e.lines,d[t].size=e.type,y+=d[t].nx*d[t].ny*d[t].size;const b=i(n,a),S=i(n,a);if(S>=o)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(b<=S)for(let t=0;t<S-b+1;t++)s[t+b]=l(n,a);const A=new Uint16Array(p),g=c(s,A),m=t(n,a);f(e.array,n,a,m,r,y);for(let t=0;t<e.channels;++t){const e=d[t];for(let n=0;n<d[t].size;++n)u(r,e.start+n,e.nx,e.size,e.ny,e.nx*e.size,g)}h(A,r,y);let z=0;const C=new Uint8Array(r.buffer.byteLength);for(let t=0;t<e.lines;t++)for(let n=0;n<e.channels;n++){const e=d[n],t=e.nx*e.size,a=new Uint8Array(r.buffer,e.end*w,t*w);C.set(a,z),z+=t*w,e.end+=t}return new DataView(C.buffer)}class L{constructor(){this.supportCascades=!1}loadCubeData(e,t,n,a,r){throw".exr not supported in Cube."}async loadData(r,s,o){const l=new DataView(r.buffer),c={value:0},f=function(r,s){if(20000630!=r.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const i=r.getUint8(4),o=r.getUint8(5),l={singleTile:!!(2&o),longName:!!(4&o),deepFormat:!!(8&o),multiPart:!!(16&o)};s.value=8;const c={};let f=!0;for(;f;){const i=e(r.buffer,s);if(i){const o=e(r.buffer,s),l=t(r,s),f=n(r,s,o,l);void 0===f?a.Warn(`Unknown header attribute type ${o}'.`):c[i]=f}else f=!1}if(-5&o)throw new Error("Unsupported file format");return{version:i,spec:l,...c}}(l,c),u=await async function(e,t,n,a){const r={size:0,viewer:t,array:new Uint8Array(t.buffer),offset:n,width:e.dataWindow.xMax-e.dataWindow.xMin+1,height:e.dataWindow.yMax-e.dataWindow.yMin+1,channels:e.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(e.compression){case y.NO_COMPRESSION:r.lines=1,r.uncompress=O;break;case y.RLE_COMPRESSION:r.lines=1,r.uncompress=x;break;case y.ZIPS_COMPRESSION:r.lines=1,r.uncompress=E,await d.LoadScriptAsync(b.FFLATEUrl);break;case y.ZIP_COMPRESSION:r.lines=16,r.uncompress=E,await d.LoadScriptAsync(b.FFLATEUrl);break;case y.PIZ_COMPRESSION:r.lines=32,r.uncompress=v;break;case y.PXR24_COMPRESSION:r.lines=16,r.uncompress=U,await d.LoadScriptAsync(b.FFLATEUrl);break;default:throw new Error(y[e.compression]+" is unsupported")}r.scanlineBlockSize=r.lines;const s={};for(const i of e.channels)switch(i.name){case"Y":case"R":case"G":case"B":case"A":s[i.name]=!0,r.type=i.pixelType}let o=!1;if(s.R&&s.G&&s.B)o=!s.A,r.outputChannels=4,r.decodeChannels={R:0,G:1,B:2,A:3};else{if(!s.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");r.outputChannels=1,r.decodeChannels={Y:0}}if(1===r.type)switch(a){case S.Float:r.getter=A,r.inputSize=w;break;case S.HalfFloat:r.getter=i,r.inputSize=w}else{if(2!==r.type)throw new Error("Unsupported pixelType "+r.type+" for "+e.compression);switch(a){case S.Float:r.getter=z,r.inputSize=m;break;case S.HalfFloat:r.getter=g,r.inputSize=m}}r.blockCount=r.height/r.scanlineBlockSize;for(let i=0;i<r.blockCount;i++)C(t,n);const l=r.width*r.height*r.outputChannels;switch(a){case S.Float:r.byteArray=new Float32Array(l),r.textureType=1,o&&r.byteArray.fill(1,0,l);break;case S.HalfFloat:r.byteArray=new Uint16Array(l),r.textureType=2,o&&r.byteArray.fill(15360,0,l);break;default:throw new Error("Unsupported type: "+a)}let c=0;for(const i of e.channels)void 0!==r.decodeChannels[i.name]&&(r.channelLineOffsets[i.name]=c*r.width),c+=2*i.pixelType;return r.bytesPerLine=r.width*c,r.outLineWidth=r.width*r.outputChannels,"INCREASING_Y"===e.lineOrder?r.scanOrder=e=>e:r.scanOrder=e=>r.height-1-e,4==r.outputChannels?(r.format=5,r.linearSpace=!0):(r.format=6,r.linearSpace=!1),r}(f,l,c,b.DefaultOutputType);!function(e,n,a,r){const s={value:0};for(let i=0;i<e.height/e.scanlineBlockSize;i++){const o=k(a,r)-n.dataWindow.yMin;e.size=t(a,r),e.lines=o+e.scanlineBlockSize>e.height?e.height-o:e.scanlineBlockSize;const l=e.size<e.lines*e.bytesPerLine&&e.uncompress?e.uncompress(e):O(e);r.value+=e.size;for(let t=0;t<e.scanlineBlockSize;t++){const a=i*e.scanlineBlockSize,r=t+e.scanOrder(a);if(r>=e.height)continue;const o=t*e.bytesPerLine,c=(e.height-1-r)*e.outLineWidth;for(let t=0;t<e.channels;t++){const a=n.channels[t].name,r=e.channelLineOffsets[a],i=e.decodeChannels[a];if(void 0!==i){s.value=o+r;for(let t=0;t<e.width;t++){const n=c+t*e.outputChannels+i;e.byteArray&&(e.byteArray[n]=e.getter(l,s))}}}}}}(u,f,l,c);o(f.dataWindow.xMax-f.dataWindow.xMin+1,f.dataWindow.yMax-f.dataWindow.yMin+1,s.generateMipMaps,!1,(()=>{const e=s.getEngine();s.format=f.format,s.type=u.textureType,s.invertY=!1,s._gammaSpace=!f.linearSpace,u.byteArray&&e._uploadDataToTextureDirectly(s,u.byteArray,0,0,void 0,!0)}))}}export{L as _ExrTextureLoader};
